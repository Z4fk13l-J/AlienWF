<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Datos del mundo</title>
    
    <!-- ==================== ESTILOS CSS ==================== -->
    <style>
        /* Reset básico para eliminar márgenes y padding por defecto */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Estilos generales del body con tema Rose Pine */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #191724; /* Fondo oscuro Rose Pine */
            color: #e0e6ed; /* Texto claro */
            padding: 20px;
            line-height: 1.6;
        }

        /* Contenedor principal centrado */
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Cabecera con título */
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
        }

        /* Título principal con degradado Rose Pine */
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #C55F7E 0%, #EB6F92 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Separador de imagen */
        .separator {
            text-align: center;
            margin: 20px auto;
            padding: 15px 0;
        }
        
        .separator img {
            height: 30px;
            width: auto;
            opacity: 0.7;
            display: inline-block;
            margin: 0;
        }

        /* Layout principal: info lateral | fisuras */
        .main-layout {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        /* Columna lateral izquierda para ciclos e invasiones */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Contenedor de 2 columnas para fisuras (Normales | Steel Path) */
        .fissures-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        /* Contenedor para Sortie y Archon Hunt */
        .missions-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 15px;
            max-width: 800px; /* Limitar ancho máximo */
            margin-left: auto;
            margin-right: 0px;
        }
        
        .mission-box {
            background: #0f1219;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #1a1f3a;
        }
        
        .mission-item {
            transition: all 0.2s;
            cursor: default;
        }
        
        .mission-item:hover {
            border-color: #667eea !important;
            transform: translateX(2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
        }

        /* Cada columna de fisuras - ULTRA COMPACTA */
        .fissure-column {
            background: #0f1219;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #1a1f3a;
        }

        /* Encabezado de cada columna - ULTRA PEQUEÑO */
        .column-header {
            font-size: 0.85rem;
            font-weight: 700;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #2a3150;
            text-align: center;
        }

        /* Grupo de fisuras por tier (Lith, Meso, Neo, etc) - ULTRA COMPACTO */
        .tier-group {
            margin-bottom: 6px;
        }

        /* Título de cada tier - ULTRA PEQUEÑO */
        .tier-title {
            font-size: 0.65rem;
            font-weight: 600;
            color: #8b95a5;
            margin-bottom: 4px;
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tier-title:first-child {
            margin-top: 0;
        }

        /* Card individual para cada fisura - ULTRA COMPACTA */
        .card {
            background: #151933;
            border: 1px solid #2a3150;
            border-radius: 4px;
            padding: 6px 8px;
            transition: all 0.2s;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        /* Efecto hover en las cards */
        .card:hover {
            border-color: #667eea;
            transform: translateX(2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
        }

        /* Info principal (tipo de misión + nodo) */
        .card-info {
            flex: 1;
            min-width: 0;
        }

        /* Título de la card (tipo de misión) */
        .card-title {
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 1px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Subtítulo de la card (nodo/planeta + facción) */
        .card-subtitle {
            color: #8b95a5;
            font-size: 0.65rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Timer de cuenta regresiva - ULTRA COMPACTO */
        .timer {
            font-size: 0.75rem;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            white-space: nowrap;
            min-width: 60px;
            text-align: right;
        }

        /* Timer cuando está por expirar (menos de 10 min) */
        .timer.expiring {
            color: #f59e0b;
            animation: pulse 2s infinite;
        }

        /* Animación de pulso para timers expirando */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Etiqueta de información (enemigo, facción, etc) - OCULTA EN COMPACTO */
        .info-tag {
            display: none;
        }

        /* Mensaje de carga */
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2rem;
            color: #8b95a5;
        }

        /* Mensaje de error */
        .error {
            background: #7f1d1d;
            border: 1px solid #991b1b;
            color: #fecaca;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }

        /* Estilos para sidebar (ciclos e invasiones) */
        .sidebar-section {
            background: #0f1219;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #1a1f3a;
        }

        .sidebar-header {
            font-size: 0.8rem;
            font-weight: 700;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #2a3150;
            text-align: center;
        }

        .sidebar-item {
            background: #151933;
            border: 1px solid #2a3150;
            border-radius: 4px;
            padding: 10px 12px;
            margin-bottom: 6px;
            font-size: 0.7rem;
            transition: all 0.2s;
            cursor: default;
        }
        
        .sidebar-item:hover {
            border-color: #667eea;
            transform: translateX(2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
        }

        .sidebar-item .timer {
            margin-top: 4px;
            font-size: 0.7rem;
            color: #8b95a5;
            text-align: left;
        }

        .sidebar-item-title {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .sidebar-item-timer {
            color: #8b95a5;
            font-size: 0.65rem;
        }

        /* Responsive: en móviles las columnas se apilan */
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .sidebar {
                order: 2;
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .fissures-container {
                grid-template-columns: 1fr;
            }
        }

        /* Footer con última actualización */
        footer {
            text-align: center;
            padding: 15px 0;
            margin-top: 30px;
            border-top: 1px solid #1a1f3a;
            color: #8b95a5;
            font-size: 0.85rem;
        }

        /* Tooltips para modificadores */
        .modifier-tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #C55F7E;
        }

        .modifier-tooltip .tooltip-content {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%) translateY(10px);
            background: #0f1219;
            color: #e0e6ed;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #2a3150;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            width: 250px;
            z-index: 1000;
            font-size: 0.65rem;
            line-height: 1.4;
            text-align: left;
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .modifier-tooltip .tooltip-content::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #2a3150;
        }

        .modifier-tooltip:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Animación de entrada suave */
        @keyframes tooltipFadeIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(10px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }
        }

        .modifier-tooltip:hover .tooltip-content {
            animation: tooltipFadeIn 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Título principal -->
        <header>
            <h1>Datos del mundo</h1>
        </header>
        
        <!-- Separador con imagen repetida -->
        <div class="separator">
            <img src="./1.gif">
            <img src="./1.gif">
            <img src="./1.gif">
            <img src="./1.gif">
            <img src="./1.gif">
            <img src="./1.gif">
            <img src="./1.gif">
            <img src="./1.gif">
            <img src="./1.gif">
        </div>
        
        <!-- Layout principal: sidebar + fisuras -->
        <div class="main-layout">
            <!-- Sidebar izquierda: ciclos e invasiones -->
            <div class="sidebar" id="sidebar">
                <div class="loading">⏳ Cargando...</div>
            </div>
            
            <!-- Contenedor de fisuras a la derecha -->
            <div id="fissures-content">
                <div class="loading">⏳ Cargando fisuras...</div>
            </div>
        </div>
        
        <!-- Sección: Sortie y Archon Hunt -->
        <div id="missions-content"></div>
        
        <!-- Sección inferior: Arquimedeas -->
        <div id="archimidean-content"></div>
        
        <!-- Sección: Rotaciones exclusivas (solo con ?view=) -->
        <div id="rotations-content"></div>
        
        <!-- Footer con timestamp de última actualización -->
        <footer>
            Última actualización: <span id="lastUpdate">Cargando...</span>
        </footer>
    </div>

    <!-- ==================== JAVASCRIPT ==================== -->
    <script>
        /* ===== CONFIGURACIÓN ===== */
        
        // URLs de la API de Warframe
        const WORLDSTATE_URL = 'https://oracle.browse.wf/worldState.json';
        const INVASIONS_URL = 'https://oracle.browse.wf/invasions';
        const WEEKLY_URL = 'https://oracle.browse.wf/weekly';
        const SORTIE_DATA_URL = 'https://raw.githubusercontent.com/WFCD/warframe-worldstate-data/master/data/sortieData.json';
        
        // Variables globales
        let gameData = {fissures: [], cycles: {}, invasions: [], archimideans: {temporal: null, deep: null}, sortie: null, archonHunt: null}; // Almacena todos los datos del juego
        let lastFissureIds = new Set(); // Para detectar nuevas fisuras
        let SORTIE_DATA = {}; // Datos de modificadores y bosses de Sortie
        
        /* ===== ROTACIONES SEMANALES (HARDCODED) ===== */
        
        // Rotación de Armas Incarnon (8 semanas, reset con Archon Hunt)
        const INCARNON_ROTATION = [
            {week: 1, weapons: ['Braton', 'Lato', 'Skana', 'Paris', 'Kunai']},
            {week: 2, weapons: ['Boar', 'Gammacor', 'Angstrum', 'Gorgon', 'Anku']},
            {week: 3, weapons: ['Bo', 'Latron', 'Furis', 'Furax', 'Strun']},
            {week: 4, weapons: ['Lex', 'Magistar', 'Boltor', 'Bronco', 'Daga Cerámica']},
            {week: 5, weapons: ['Torid', 'Toxocyst Dobles', 'Ichor Dobles', 'Miter', 'Atomos']},
            {week: 6, weapons: ['Ack & Brunt', 'Soma', 'Vasto', 'Nami Solo', 'Burston']},
            {week: 7, weapons: ['Zylok', 'Sibear', 'Dread', 'Despair', 'Hate']},
            {week: 8, weapons: ['Dera', 'Sybaris', 'Cestra', 'Sicarus', 'Okina']}
        ];
        
        // Rotación de Warframes en Circuito (11 semanas, reset con Archon Hunt)
        const CIRCUIT_ROTATION = [
            {week: 1, frames: ['Excalibur', 'Trinity', 'Ember']},
            {week: 2, frames: ['Loki', 'Mag', 'Rhino']},
            {week: 3, frames: ['Ash', 'Frost', 'Nyx']},
            {week: 4, frames: ['Saryn', 'Vauban', 'Nova']},
            {week: 5, frames: ['Nekros', 'Valkyr', 'Oberon']},
            {week: 6, frames: ['Hydroid', 'Mirage', 'Limbo']},
            {week: 7, frames: ['Mesa', 'Chroma', 'Atlas']},
            {week: 8, frames: ['Ivara', 'Inaros', 'Titania']},
            {week: 9, frames: ['Nidus', 'Octavia', 'Harrow']},
            {week: 10, frames: ['Gara', 'Khora', 'Revenant']},
            {week: 11, frames: ['Garuda', 'Baruuk', 'Hildryn']}
        ];
        
        // Rotación de Tienda de Teshin (8 semanas, reset con Archon Hunt)
        const TESHIN_ROTATION = [
            {week: 1, items: [{name: 'Forma Umbra', cost: '150 Esencias'}]},
            {week: 2, items: [{name: '50.000 Kuva', cost: '55 Esencias'}]},
            {week: 3, items: [{name: 'Riven de Kitgun', cost: '75 Esencias'}]},
            {week: 4, items: [{name: 'Paquete de formas', cost: '75 Esencias'}]},
            {week: 5, items: [{name: 'Riven de Zaw', cost: '75 Esencias'}]},
            {week: 6, items: [{name: '30.000 de Endo', cost: '150 Esencias'}]},
            {week: 7, items: [{name: 'Riven de Rifle', cost: '75 Esencias'}]},
            {week: 8, items: [{name: 'Riven de Escopeta', cost: '75 Esencias'}]}
        ];
        
        // Calcular semana actual automáticamente (reset lunes 00:00 UTC)
        // EPOCHS CALIBRADOS PARA: Incarnon semana 5, Circuito semana 5, Teshin semana 1
        function getCurrentWeek(totalWeeks, rotationType) {
            const now = Date.now();
            
            // Epochs específicos por tipo de rotación (calibrados 9 dic 2025)
            let mondayEpoch;
            if (rotationType === 'incarnon') {
                mondayEpoch = 1699833600000; // Para que hoy sea semana 5 de 8
            } else if (rotationType === 'circuit') {
                mondayEpoch = 1702857600000; // Para que hoy sea semana 5 de 11
            } else if (rotationType === 'teshin') {
                mondayEpoch = 1702252800000; // Para que hoy sea semana 1 de 8
            } else {
                mondayEpoch = new Date('2024-01-01T00:00:00Z').getTime();
            }
            
            const weeksSinceEpoch = Math.floor((now - mondayEpoch) / (7 * 24 * 60 * 60 * 1000));
            return (weeksSinceEpoch % totalWeeks) + 1;
        }
        
        /* ===== MAPEOS DE DATOS ===== */
        
        // Mapeo de tiers de reliquias
        const TIER_MAP = {
            'VoidT1': 'Lith',
            'VoidT2': 'Meso', 
            'VoidT3': 'Neo',
            'VoidT4': 'Axi',
            'VoidT5': 'Requiem',
            'VoidT6': 'Omni'
        };
        
        // Traducción de planetas al español
        const PLANET_TRANSLATION = {
            'Mercury': 'Mercurio',
            'Venus': 'Venus',
            'Earth': 'Tierra',
            'Mars': 'Marte',
            'Phobos': 'Fobos',
            'Ceres': 'Ceres',
            'Jupiter': 'Júpiter',
            'Europa': 'Europa',
            'Saturn': 'Saturno',
            'Uranus': 'Urano',
            'Neptune': 'Neptuno',
            'Pluto': 'Plutón',
            'Sedna': 'Sedna',
            'Eris': 'Eris',
            'Void': 'Vacío',
            'Lua': 'Lua',
            'Deimos': 'Deimos',
            'Zariman': 'Zariman',
            'Duviri': 'Duviri',
            'Kuva Fortress': 'Fortaleza Kuva',
            'Unknown': 'Desconocido'
        };

        // Orden de tiers para mostrar
        const TIER_ORDER = ['Lith', 'Meso', 'Neo', 'Axi', 'Requiem', 'Omni'];

        // Mapeo de tipos de misión a español
        const MISSION_MAP = {
            'MT_EXCAVATE': 'Excavación',
            'MT_EXTERMINATION': 'Exterminio',
            'MT_SURVIVAL': 'Supervivencia',
            'MT_RESCUE': 'Rescate',
            'MT_SABOTAGE': 'Sabotaje',
            'MT_CAPTURE': 'Captura',
            'MT_MOBILE_DEFENSE': 'Defensa móvil',
            'MT_DEFENSE': 'Defensa',
            'MT_ASSASSINATION': 'Asesinato',
            'MT_INTEL': 'Espionaje',
            'MT_ARTIFACT': 'Interrupción',
            'MT_TERRITORY': 'Interceptación',
            'MT_EVACUATION': 'Evacuación',
            'MT_HIVE': 'Colmena',
            'MT_RETRIEVAL': 'Usurpación',
            'MT_ASSAULT': 'Acometida',
            'MT_ARENA': 'Arena',
            'MT_ALCHEMY': 'Alquimia',
            'MT_VOID_CASCADE': 'Cascada del vacío',
            'MT_CORRUPTION': 'Inundación del vacío',
            'MT_LANDSCAPE': 'Recorrido libre',
            'MT_RACE': 'Estampida',
            'MT_PURSUIT': 'Persecución',
        };

        // Almacena información de nodos (planetas, enemigos)
        let NODE_DATA = {};
        
        /* ===== FUNCIONES DE DATOS ===== */
        
        // Cargar datos de nodos desde GitHub
        async function loadNodeData() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/WFCD/warframe-worldstate-data/master/data/solNodes.json');
                const data = await response.json();
                NODE_DATA = data;
                console.log('Nodos cargados:', Object.keys(NODE_DATA).length);
            } catch (error) {
                console.error('Error cargando nodos:', error);
            }
        }
        
        // Cargar datos de Sortie (modificadores y bosses)
        async function loadSortieData() {
            try {
                const response = await fetch(SORTIE_DATA_URL);
                const data = await response.json();
                SORTIE_DATA = data;
                console.log('Datos de Sortie cargados');
            } catch (error) {
                console.error('Error cargando datos de Sortie:', error);
            }
        }

        // Obtener información de un nodo específico
        function getNodeInfo(nodeKey) {
            const nodeInfo = NODE_DATA[nodeKey];
            if (nodeInfo) {
                // Traducir el planeta en el nombre del nodo
                let nodeName = nodeInfo.value || nodeKey;
                // Buscar si contiene un planeta entre paréntesis y traducirlo
                const planetMatch = nodeName.match(/\(([^)]+)\)/);
                if (planetMatch) {
                    const planet = planetMatch[1];
                    const translatedPlanet = PLANET_TRANSLATION[planet] || planet;
                    nodeName = nodeName.replace(`(${planet})`, `(${translatedPlanet})`);
                }
                
                return {
                    name: nodeName,
                    enemy: nodeInfo.enemy || 'Desconocido',
                    type: nodeInfo.type || 'Desconocido'
                };
            }
            return {
                name: nodeKey,
                enemy: 'Desconocido',
                type: 'Desconocido'
            };
        }
        
        /* ===== FUNCIONES DE TIEMPO ===== */
        
        // Formatear milisegundos a texto legible (ej: 2h 15m 30s)
        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) return `${days}d ${hours % 24}h ${minutes % 60}m`;
            if (hours > 0) return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
            if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
            return `${seconds}s`;
        }

        // Calcular tiempo restante hasta que expire
        function getTimeRemaining(expiry) {
            return new Date(expiry) - Date.now();
        }

        // Verificar si una fisura está por expirar (menos de 10 min)
        function isExpiringSoon(ms) {
            return ms > 0 && ms < 600000; // 600000ms = 10 minutos
        }
        
        /* ===== FUNCIONES DE RENDERIZADO ===== */
        
        // Función principal que genera el HTML de las fisuras
        function renderFissures(fissures) {
            // Validar que hay fisuras
            if (!fissures || !Array.isArray(fissures)) {
                return '<div class="error">No se pudieron cargar las fisuras</div>';
            }

            if (fissures.length === 0) {
                return '<div class="error">No hay fisuras activas en este momento</div>';
            }

            // Separar fisuras normales y Steel Path
            const normalFissures = fissures.filter(f => !f.isHard);
            const steelPath = fissures.filter(f => f.isHard);

            let html = '<div class="fissures-container">';

            // ===== COLUMNA: FISURAS NORMALES =====
            html += '<div class="fissure-column">';
            html += '<div class="column-header" style="color: #EB6F92;">Normales</div>';
            
            if (normalFissures.length > 0) {
                // Agrupar fisuras por tier
                const byTier = {};
                TIER_ORDER.forEach(tier => { byTier[tier] = []; });
                
                normalFissures.forEach(fissure => {
                    const tier = fissure.tier || 'Unknown';
                    if (byTier[tier]) {
                        byTier[tier].push(fissure);
                    }
                });

                // Renderizar cada tier
                TIER_ORDER.forEach(tier => {
                    const tierFissures = byTier[tier];
                    if (tierFissures && tierFissures.length > 0) {
                        html += `<div class="tier-group">`;
                        html += `<div class="tier-title">${tier}</div>`;
                        
                        tierFissures.forEach(fissure => {
                            const remaining = getTimeRemaining(fissure.expiry);
                            const timerClass = isExpiringSoon(remaining) ? 'timer expiring' : 'timer';
                            
                            html += `
                                <div class="card" data-fissure-id="${fissure.id}">
                                    <div class="card-info">
                                        <div class="card-title">${fissure.missionType} <span class="card-subtitle">${fissure.node} - ${fissure.enemy}</span></div>
                                    </div>
                                    <div class="${timerClass}" data-expiry="${fissure.expiry}">
                                        ${formatTime(remaining)}
                                    </div>
                                </div>
                            `;
                        });
                        html += '</div>';
                    }
                });
            } else {
                html += '<div class="card"><div class="card-info"><div class="card-title">No hay fisuras normales activas</div></div></div>';
            }
            html += '</div>';

            // ===== COLUMNA: STEEL PATH =====
            html += '<div class="fissure-column">';
            html += '<div class="column-header" style="color: #EB6F92;">Camino de acero</div>';
            
            if (steelPath.length > 0) {
                // Agrupar fisuras por tier
                const byTier = {};
                TIER_ORDER.forEach(tier => { byTier[tier] = []; });
                
                steelPath.forEach(fissure => {
                    const tier = fissure.tier || 'Unknown';
                    if (byTier[tier]) {
                        byTier[tier].push(fissure);
                    }
                });

                // Renderizar cada tier
                TIER_ORDER.forEach(tier => {
                    const tierFissures = byTier[tier];
                    if (tierFissures && tierFissures.length > 0) {
                        html += `<div class="tier-group">`;
                        html += `<div class="tier-title">${tier}</div>`;
                        
                        tierFissures.forEach(fissure => {
                            const remaining = getTimeRemaining(fissure.expiry);
                            const timerClass = isExpiringSoon(remaining) ? 'timer expiring' : 'timer';
                            
                            html += `
                                <div class="card" data-fissure-id="${fissure.id}">
                                    <div class="card-info">
                                        <div class="card-title">${fissure.missionType} <span class="card-subtitle">${fissure.node} - ${fissure.enemy}</span></div>
                                    </div>
                                    <div class="${timerClass}" data-expiry="${fissure.expiry}">
                                        ${formatTime(remaining)}
                                    </div>
                                </div>
                            `;
                        });
                        html += '</div>';
                    }
                });
            } else {
                html += '<div class="card"><div class="card-info"><div class="card-title">No hay fisuras Steel Path activas</div></div></div>';
            }
            html += '</div>';

            html += '</div>';
            return html;
        }
        
        // Renderizar Sortie y Archon Hunt en contenedor separado
        function renderMissions() {
            const sortie = gameData.sortie;
            const archonHunt = gameData.archonHunt;
            
            // Filtrar según VIEW_FILTER
            const showSortie = !window.VIEW_FILTER || window.VIEW_FILTER === 'sortie';
            const showArchon = !window.VIEW_FILTER || window.VIEW_FILTER === 'archon';
            
            if ((!sortie || !showSortie) && (!archonHunt || !showArchon)) return '';
            
            let html = '<div class="missions-container">';
            
            // Sortie
            if (sortie && showSortie) {
                const remaining = getTimeRemaining(sortie.expiry);
                html += '<div class="mission-box">';
                html += `<div style="font-size: 0.85rem; font-weight: 700; margin-bottom: 10px; color: #EB6F92; text-align: center; padding-bottom: 8px; border-bottom: 1px solid #2a3150;">Sortie - ${sortie.boss}</div>`;
                html += `<div style="font-size: 0.7rem; color: #8b95a5; text-align: center; margin-bottom: 10px;">Rota en: <span class="timer" data-expiry="${sortie.expiry}">${formatTime(remaining)}</span></div>`;
                
                sortie.missions.forEach(mission => {
                    html += `<div class="mission-item" style="margin-bottom: 8px; padding: 8px; background: #151933; border-radius: 4px; border: 1px solid #2a3150;">`;
                    html += `<div style="font-size: 0.75rem; font-weight: 600; margin-bottom: 3px;">${mission.index}. ${mission.missionType}</div>`;
                    html += `<div style="font-size: 0.65rem; color: #8b95a5; margin-bottom: 2px;">${mission.node} - ${mission.enemy}</div>`;
                    html += `<div style="font-size: 0.65rem; color: #C55F7E;">${mission.modifier}</div>`;
                    html += `</div>`;
                });
                
                html += '</div>';
            }
            
            // Archon Hunt
            if (archonHunt && showArchon) {
                const remaining = getTimeRemaining(archonHunt.expiry);
                html += '<div class="mission-box">';
                html += `<div style="font-size: 0.85rem; font-weight: 700; margin-bottom: 8px; color: #EB6F92; text-align: center; padding-bottom: 8px; border-bottom: 1px solid #2a3150;">${archonHunt.boss}</div>`;
                html += `<div style="font-size: 0.65rem; color: #C55F7E; text-align: center; margin-bottom: 8px;">${archonHunt.crystal}</div>`;
                html += `<div style="font-size: 0.7rem; color: #8b95a5; text-align: center; margin-bottom: 10px;">Rota en: <span class="timer" data-expiry="${archonHunt.expiry}">${formatTime(remaining)}</span></div>`;
                
                archonHunt.missions.forEach(mission => {
                    html += `<div class="mission-item" style="margin-bottom: 8px; padding: 8px; background: #151933; border-radius: 4px; border: 1px solid #2a3150;">`;
                    html += `<div style="font-size: 0.75rem; font-weight: 600; margin-bottom: 3px;">${mission.index}. ${mission.missionType}</div>`;
                    html += `<div style="font-size: 0.65rem; color: #8b95a5;">${mission.node} - ${mission.enemy}</div>`;
                    html += `</div>`;
                });
                
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }
        
        /* ===== FUNCIONES DE PARSEO ===== */
        
        // Parsear ciclo planetario genérico desde SyndicateMissions
        function parseCycle(syndicateMissions, tag) {
            const mission = (syndicateMissions || []).find(m => m.Tag === tag);
            if (!mission) return null;
            
            // Si no hay expiry, calcular uno genérico
            const activation = mission.Activation ? new Date(parseInt(mission.Activation.$date.$numberLong)) : new Date();
            const elapsed = Date.now() - activation.getTime();
            
            if (tag === 'CetusSyndicate') {
                // Cetus: 100min día, 50min noche
                const dayDuration = 100 * 60 * 1000;
                const nightDuration = 50 * 60 * 1000;
                const cycleTime = elapsed % (dayDuration + nightDuration);
                const isDay = cycleTime < dayDuration;
                const timeInPhase = isDay ? cycleTime : cycleTime - dayDuration;
                const phaseDuration = isDay ? dayDuration : nightDuration;
                const timeRemaining = phaseDuration - timeInPhase;
                const nextExpiry = new Date(Date.now() + timeRemaining);
                return { isDay, expiry: nextExpiry.toISOString() };
            } else if (tag === 'SolarisSyndicate') {
                // Orb Vallis: Hardcodeado - calor empieza 8 dic 2025 23:20 UTC
                const referenceTime = 1765215228000; // 8 dic 2025, 23:20:00 UTC
                const warmDuration = 400 * 1000;  // 6:40 = 400 segundos
                const coldDuration = 1200 * 1000; // 20:00 = 1200 segundos
                const totalCycle = warmDuration + coldDuration; // 1600s = 26:40
                
                const now = Date.now();
                const elapsed = now - referenceTime;
                const cycleTime = ((elapsed % totalCycle) + totalCycle) % totalCycle;
                
                // Empieza en calor en el reference time
                const isWarm = cycleTime < warmDuration;
                const timeInPhase = isWarm ? cycleTime : (cycleTime - warmDuration);
                const phaseDuration = isWarm ? warmDuration : coldDuration;
                const timeRemaining = phaseDuration - timeInPhase;
                const nextExpiry = new Date(now + timeRemaining);
                return { isWarm, expiry: nextExpiry.toISOString() };
            }
            
            return null;
        }
        
        // Parsear ciclo de Cambion (Fass/Vome) basado en timestamp
        function parseCambionCycle(cetusData) {
            // Cambion está sincronizado con Cetus: día=Fass, noche=Vome
            if (!cetusData) return null;
            
            return {
                active: cetusData.isDay ? 'fass' : 'vome',
                expiry: cetusData.expiry
            };
        }
        
        // Parsear ciclo de Zariman (Grineer/Corpus control)
        function parseZarimanCycle() {
            // Zariman alterna entre Grineer y Corpus cada 150 minutos
            const phaseMs = 150 * 60 * 1000;  // 150 minutos por fase
            const cycleMs = phaseMs * 2; // 300 minutos total
            
            // Reference calculado: inicio de un ciclo de Corpus
            const reference = 1765220979456; // Ajustado para coincidir exactamente
            const now = Date.now();
            const elapsed = now - reference;
            const cyclePosition = elapsed % cycleMs;
            const isCorpus = cyclePosition < phaseMs;
            
            const timeInPhase = isCorpus ? cyclePosition : cyclePosition - phaseMs;
            const timeRemaining = phaseMs - timeInPhase;
            const nextChange = new Date(now + timeRemaining);
            
            return {
                state: isCorpus ? 'Corpus' : 'Grineer',
                expiry: nextChange.toISOString()
            };
        }
        
        // Parsear ciclo de Duviri (Joy, Anger, Envy, Sorrow, Fear)
        function parseDuviriCycle() {
            // Duviri rota entre 5 moods cada 2 horas
            const moods = ['Miedo', 'Alegría', 'Ira', 'Envidia', 'Tristeza'];
            const cycleMs = 2 * 60 * 60 * 1000; // 2 horas por mood
            
            // Timestamp de referencia (inicio de Duviri Paradox: 26 Abril 2023)
            const referenceStart = 1682467200000; // 26 Apr 2023 00:00 UTC
            const now = Date.now();
            const elapsed = now - referenceStart;
            const totalCycles = Math.floor(elapsed / cycleMs);
            const currentMoodIndex = totalCycles % moods.length;
            
            const cycleStart = referenceStart + (totalCycles * cycleMs);
            const nextChange = new Date(cycleStart + cycleMs);
            
            return {
                state: moods[currentMoodIndex],
                expiry: nextChange.toISOString()
            };
        }
        
        // Cache para nombres de items
        const itemNameCache = {};
        
        // Obtener nombre de item desde browse.wf
        async function getItemName(itemPath, itemCount) {
            if (!itemPath) return 'Unknown';
            
            // Verificar cache
            if (itemNameCache[itemPath]) {
                return `${itemCount}x ${itemNameCache[itemPath]}`;
            }
            
            try {
                // Obtener el archivo del item
                const itemResponse = await fetch(`https://browse.wf${itemPath}`);
                const itemData = await itemResponse.json();
                
                // Buscar el campo "name" que contiene la ruta al nombre traducido
                const namePath = itemData.name;
                if (!namePath) {
                    const fallback = itemPath.split('/').pop().replace(/([A-Z])/g, ' $1').trim();
                    itemNameCache[itemPath] = fallback;
                    return `${itemCount}x ${fallback}`;
                }
                
                // Obtener el nombre traducido en español
                const nameResponse = await fetch(`https://browse.wf${namePath}`);
                const nameData = await nameResponse.json();
                
                const spanishName = nameData.es || nameData.en || 'Unknown';
                itemNameCache[itemPath] = spanishName;
                return `${itemCount}x ${spanishName}`;
            } catch (error) {
                console.error('Error obteniendo nombre de item:', error);
                const fallback = itemPath.split('/').pop().replace(/([A-Z])/g, ' $1').trim();
                return `${itemCount}x ${fallback}`;
            }
        }
        
        // Parsear invasiones desde el endpoint /invasions
        async function parseInvasions(invasions) {
            // Agrupar invasiones por nodo (cada nodo puede tener 1 o 2 lados)
            const byNode = {};
            invasions.forEach(inv => {
                if (!byNode[inv.node]) {
                    byNode[inv.node] = [];
                }
                byNode[inv.node].push(inv);
            });
            
            // Mapear facciones
            const factionMap = {
                'FC_GRINEER': 'Grineer',
                'FC_CORPUS': 'Corpus',
                'FC_INFESTATION': 'Infestados'
            };
            
            // Convertir a lista de invasiones
            const result = [];
            for (const node in byNode) {
                const sides = byNode[node];
                const nodeInfo = getNodeInfo(node);
                
                if (sides.length >= 2) {
                    // Invasión con 2 facciones
                    const faction1 = factionMap[sides[0].ally] || sides[0].ally;
                    const faction2 = factionMap[sides[1].ally] || sides[1].ally;
                    
                    // Obtener recompensas con nombres reales
                    const reward1Promise = sides[0].allyPay && sides[0].allyPay[0] 
                        ? getItemName(sides[0].allyPay[0].ItemType, sides[0].allyPay[0].ItemCount)
                        : Promise.resolve('Unknown');
                    const reward2Promise = sides[1].allyPay && sides[1].allyPay[0]
                        ? getItemName(sides[1].allyPay[0].ItemType, sides[1].allyPay[0].ItemCount)
                        : Promise.resolve('Unknown');
                    
                    const [reward1, reward2] = await Promise.all([reward1Promise, reward2Promise]);
                    
                    result.push({
                        node: nodeInfo.name,
                        attacker: faction1,
                        defender: faction2,
                        reward1: reward1,
                        reward2: reward2,
                        missions: sides[0].missions || [],
                        completion: 50
                    });
                } else if (sides.length === 1) {
                    // Invasión con 1 facción (contra Infestados - sin recompensa)
                    const faction = factionMap[sides[0].ally] || sides[0].ally;
                    const reward = sides[0].allyPay && sides[0].allyPay[0]
                        ? await getItemName(sides[0].allyPay[0].ItemType, sides[0].allyPay[0].ItemCount)
                        : 'Unknown';
                    
                    result.push({
                        node: nodeInfo.name,
                        attacker: faction,
                        defender: 'Infestados',
                        reward1: reward,
                        reward2: null, // No hay recompensa por defender infestados
                        missions: sides[0].missions || [],
                        completion: 50
                    });
                }
            }
            
            return result;
        }
        
        // Parsear arquimedeas desde el endpoint /weekly
        function parseArchimideans(data) {
            const result = { temporal: null, deep: null };
            
            if (!data || !data.expiry) return result;
            
            const expiry = new Date(data.expiry * 1000); // timestamp en segundos
            
            // Hex Conquest (Temporal) - Hollvania
            if (data.hexConquestMissions && data.hexConquestMissions.length > 0) {
                result.temporal = {
                    missions: data.hexConquestMissions,
                    personalMods: data.hexConquestFrameVariables || [],
                    location: 'Höllvania',
                    expiry: expiry.toISOString()
                };
            }
            
            // Lab Conquest (Profunda) - Sanctum Anatomica
            if (data.labConquestMissions && data.labConquestMissions.length > 0) {
                result.deep = {
                    missions: data.labConquestMissions,
                    personalMods: data.labConquestFrameVariables || [],
                    location: 'Sanctum Anatomica',
                    expiry: expiry.toISOString()
                };
            }
            
            return result;
        }
        
        // Parsear Sortie diaria
        function parseSortie(sorties) {
            if (!sorties || sorties.length === 0) return null;
            
            const sortie = sorties[0];
            const expiry = new Date(parseInt(sortie.Expiry.$date.$numberLong));
            const bossKey = sortie.Boss;
            const bossData = SORTIE_DATA.bosses ? SORTIE_DATA.bosses[bossKey] : null;
            
            return {
                boss: bossData ? bossData.name : bossKey,
                faction: bossData ? bossData.faction : 'Unknown',
                expiry: expiry.toISOString(),
                missions: (sortie.Variants || []).map((variant, idx) => {
                    const nodeInfo = getNodeInfo(variant.node);
                    const missionType = MISSION_MAP[variant.missionType] || variant.missionType;
                    const modifierKey = variant.modifierType;
                    const modifierName = SORTIE_DATA.modifierTypes ? SORTIE_DATA.modifierTypes[modifierKey] : modifierKey;
                    
                    return {
                        index: idx + 1,
                        node: nodeInfo.name,
                        missionType: missionType,
                        modifier: modifierName,
                        enemy: nodeInfo.enemy
                    };
                })
            };
        }
        
        // Parsear Archon Hunt (LiteSorties)
        function parseArchonHunt(liteSorties) {
            if (!liteSorties || liteSorties.length === 0) return null;
            
            const archonHunt = liteSorties[0];
            const expiry = new Date(parseInt(archonHunt.Expiry.$date.$numberLong));
            const bossKey = archonHunt.Boss;
            const bossData = SORTIE_DATA.bosses ? SORTIE_DATA.bosses[bossKey] : null;
            
            // Traducir nombre de Archon a español
            let bossName = bossData ? bossData.name : bossKey;
            if (bossName.startsWith('Archon ')) {
                bossName = bossName.replace('Archon ', 'Arconte ');
            }
            
            // Determinar cristal según el arconte
            const crystalMap = {
                'SORTIE_BOSS_AMAR': 'Fragmento de arconte carmesí',
                'SORTIE_BOSS_BOREAL': 'Fragmento de arconte celeste',
                'SORTIE_BOSS_NIRA': 'Fragmento de arconte ámbar'
            };
            const crystal = crystalMap[bossKey] || 'Fragmento de arconte';
            
            return {
                boss: bossName,
                crystal: crystal,
                faction: bossData ? bossData.faction : 'Narmer',
                expiry: expiry.toISOString(),
                missions: (archonHunt.Missions || []).map((mission, idx) => {
                    const nodeInfo = getNodeInfo(mission.node);
                    const missionType = MISSION_MAP[mission.missionType] || mission.missionType;
                    
                    return {
                        index: idx + 1,
                        node: nodeInfo.name,
                        missionType: missionType,
                        enemy: nodeInfo.enemy
                    };
                })
            };
        }
        
        /* ===== FUNCIONES DE ACTUALIZACIÓN ===== */
        
        // Actualizar todos los timers en pantalla (se ejecuta cada segundo)
        function updateTimers() {
            document.querySelectorAll('.timer[data-expiry]').forEach(timer => {
                const expiry = timer.dataset.expiry;
                const remaining = getTimeRemaining(expiry);
                
                if (remaining <= 0) {
                    timer.textContent = 'Expiró';
                    timer.classList.add('expiring');
                } else {
                    timer.textContent = formatTime(remaining);
                    if (isExpiringSoon(remaining)) {
                        timer.classList.add('expiring');
                    } else {
                        timer.classList.remove('expiring');
                    }
                }
            });

            // Actualizar timestamp en footer
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString('es-ES');
        }

        // Cargar datos desde la API
        async function fetchData() {
            try {
                const response = await fetch(WORLDSTATE_URL);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Parsear fisuras desde ActiveMissions
                const currentFissureIds = new Set();
                const fissures = (data.ActiveMissions || [])
                    .filter(mission => {
                        // Filtrar solo fisuras activas (no expiradas)
                        const expiry = new Date(parseInt(mission.Expiry.$date.$numberLong));
                        return expiry > Date.now();
                    })
                    .map(mission => {
                        const id = mission._id.$oid;
                        currentFissureIds.add(id);
                        
                        const expiry = new Date(parseInt(mission.Expiry.$date.$numberLong));
                        const tier = TIER_MAP[mission.Modifier] || mission.Modifier;
                        const missionType = MISSION_MAP[mission.MissionType] || mission.MissionType;
                        const nodeInfo = getNodeInfo(mission.Node);
                        
                        return {
                            id: id,
                            tier: tier,
                            missionType: missionType,
                            node: nodeInfo.name,
                            enemy: nodeInfo.enemy,
                            expiry: expiry.toISOString(),
                            isHard: mission.Hard || false
                        };
                    });
                
                // Detectar nuevas fisuras
                const newFissures = Array.from(currentFissureIds).filter(id => !lastFissureIds.has(id));
                if (newFissures.length > 0 && lastFissureIds.size > 0) {
                    console.log('Nuevas fisuras detectadas:', newFissures.length);
                }
                
                lastFissureIds = currentFissureIds;
                console.log('Fisuras activas:', fissures.length);

                // Parsear ciclos planetarios
                const cetusData = parseCycle(data.SyndicateMissions, 'CetusSyndicate');
                const cycles = {
                    cetus: cetusData,
                    vallis: parseCycle(data.SyndicateMissions, 'SolarisSyndicate'),
                    cambion: parseCambionCycle(cetusData),
                    zariman: parseZarimanCycle(),
                    duviri: parseDuviriCycle()
                };
                
                // Obtener invasiones de su endpoint
                const invasionsResponse = await fetch(INVASIONS_URL);
                const invasionsData = await invasionsResponse.json();
                const invasions = await parseInvasions(invasionsData.invasions || []);
                
                // Obtener arquimedeas de su endpoint
                const weeklyResponse = await fetch(WEEKLY_URL);
                const weeklyData = await weeklyResponse.json();
                const archimideans = parseArchimideans(weeklyData);
                
                // Parsear Sortie y Archon Hunt desde worldState
                const sortie = parseSortie(data.Sorties);
                const archonHunt = parseArchonHunt(data.LiteSorties);

                // Guardar datos y renderizar
                gameData = { fissures, cycles, invasions, archimideans, sortie, archonHunt };
                render();
                
            } catch (error) {
                console.error('❌ Error:', error);
                document.getElementById('fissures-content').innerHTML = `
                    <div class="error">
                        ❌ Error al cargar datos: ${error.message}
                        <br><small>Reintentando en 10 segundos...</small>
                    </div>
                `;
                setTimeout(fetchData, 10000);
            }
        }

        // Renderizar todo el contenido
        function render() {
            // Renderizar fisuras
            const fissuresHtml = renderFissures(Array.isArray(gameData.fissures) ? gameData.fissures : []);
            document.getElementById('fissures-content').innerHTML = fissuresHtml;
            
            // Renderizar Sortie y Archon Hunt
            const missionsHtml = renderMissions();
            document.getElementById('missions-content').innerHTML = missionsHtml;
            
            // Renderizar sidebar (ciclos e invasiones)
            renderSidebar();
            
            // Renderizar arquimedeas
            renderArchimideans();
        }
        
        // Diccionario de traducciones de Oracle (se carga dinámicamente)
        let oracleTranslations = {};
        
        // Cargar diccionario de traducciones desde Oracle
        async function loadOracleTranslations() {
            try {
                const response = await fetch('https://oracle.browse.wf/dicts/es.json');
                if (response.ok) {
                    oracleTranslations = await response.json();
                    console.log('Diccionario de traducciones cargado:', Object.keys(oracleTranslations).length, 'entradas');
                }
            } catch (error) {
                console.error('Error cargando traducciones:', error);
            }
        }
        
        // Obtener traducción desde el diccionario de Oracle
        function getTranslation(key, type = 'Condition', conquestType = null) {
            // Caso especial para variantes que tienen prefijo HexConquest o LabConquest
            if (type === 'Variant' && conquestType) {
                const fullPath = `/Lotus/Language/Conquest/MissionVariant_${conquestType}Conquest_${key}`;
                return oracleTranslations[fullPath] || key;
            }
            
            // Buscar en el diccionario con el path completo
            const fullPath = `/Lotus/Language/Conquest/${type}_${key}`;
            return oracleTranslations[fullPath] || key;
        }
        
        // Obtener descripción desde el diccionario de Oracle
        function getDescription(key, type = 'Condition', conquestType = null) {
            // Caso especial para variantes que tienen prefijo HexConquest o LabConquest
            if (type === 'Variant' && conquestType) {
                const fullPath = `/Lotus/Language/Conquest/MissionVariant_${conquestType}Conquest_${key}_Desc`;
                return oracleTranslations[fullPath] || '';
            }
            
            const fullPath = `/Lotus/Language/Conquest/${type}_${key}_Desc`;
            return oracleTranslations[fullPath] || '';
        }
        
        // Traducir tipos de misión (estos no están en Conquest)
        function translateMissionType(type) {
            const missionTypes = {
                'Survival': 'Supervivencia',
                'Defense': 'Defensa',
                'Exterminate': 'Exterminio',
                'Assassination': 'Asesinato',
                'Artifact': 'Interrupción',
                'Excavate': 'Excavación',
                'Capture': 'Captura',
                'Rescue': 'Rescate',
                'Sabotage': 'Sabotaje'
            };
            return missionTypes[type] || type;
        }
        
        // Renderizar arquimedeas
        function renderArchimideans() {
            const archimideans = gameData.archimideans || {};
            let html = '';
            
            if (archimideans.temporal || archimideans.deep) {
                // Layout vertical cuando es view exclusiva de arquimedeas
                const isArquimideasView = window.VIEW_FILTER === 'arquimedeas';
                const outerContainerStyle = isArquimideasView ? 'margin-top: 20px; padding: 15px; background: #0F1219; border-radius: 8px; max-width: 600px; margin-left: auto; margin-right: auto;' : 'margin-top: 20px; padding: 15px; background: #0F1219; border-radius: 8px;';
                html += `<div style="${outerContainerStyle}">`;
                
                // Calcular tiempo de rotación (usar el menor de los dos)
                let rotationTime = '';
                if (archimideans.temporal) {
                    rotationTime = `<span class="timer" data-expiry="${archimideans.temporal.expiry}">${formatTime(getTimeRemaining(archimideans.temporal.expiry))}</span>`;
                } else if (archimideans.deep) {
                    rotationTime = `<span class="timer" data-expiry="${archimideans.deep.expiry}">${formatTime(getTimeRemaining(archimideans.deep.expiry))}</span>`;
                }
                
                html += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">`;
                html += `<h2 style="font-size: 1rem; margin: 0; color: #EB6F92;"></h2>`;
                html += `<div style="font-size: 0.75rem; color: #8b95a5;">Rotan en: ${rotationTime}</div>`;
                html += `</div>`;
                
                const containerStyle = isArquimideasView ? 'max-width: 600px; margin: 0 auto;' : '';
                const gridStyle = isArquimideasView ? 'display: flex; flex-direction: column; gap: 15px;' : 'display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 15px;';
                html += `<div style="${containerStyle}"><div style="${gridStyle}">`;
                
                // Arquimedea Profunda primero en view exclusiva
                if (isArquimideasView && archimideans.deep) {
                    html += '<div style="background: #151933; border: 1px solid #2a3150; border-radius: 6px; padding: 12px;">';
                    html += `<div style="font-size: 0.9rem; font-weight: 700; margin-bottom: 10px; color: #EB6F92;">Arquimedea profunda - ${archimideans.deep.location}</div>`;
                    
                    // Personal Mods para Profunda
                    if (archimideans.deep.personalMods && archimideans.deep.personalMods.length > 0) {
                        html += '<div style="margin-bottom: 12px; padding: 8px; background: #1a1f3a; border-radius: 4px; border: 1px solid #2a3150;">';
                        html += '<div style="font-size: 0.7rem; font-weight: 600; margin-bottom: 6px; color: #ffffff;">Modificadores Personales:</div>';
                        const modsHtml = archimideans.deep.personalMods.map(mod => {
                            const modName = getTranslation(mod, 'PersonalMod');
                            const modDesc = getDescription(mod, 'PersonalMod');
                            if (modDesc) {
                                return `<span class="modifier-tooltip" style="display: inline-block; margin: 2px 4px; padding: 3px 8px; background: #0f1219; border-radius: 3px; font-size: 0.65rem;">${modName}<span class="tooltip-content">${modDesc}</span></span>`;
                            }
                            return `<span style="display: inline-block; margin: 2px 4px; padding: 3px 8px; background: #0f1219; border-radius: 3px; font-size: 0.65rem;">${modName}</span>`;
                        }).join('');
                        html += `<div style="display: flex; flex-wrap: wrap;">${modsHtml}</div>`;
                        html += '</div>';
                    }
                    
                    archimideans.deep.missions.forEach((mission, idx) => {
                        const missionType = translateMissionType(mission.type);
                        const variant = mission.variant ? getTranslation(mission.variant, 'Variant', 'Lab') : '';
                        
                        html += `<div class="mission-item" style="margin-bottom: 8px; padding: 8px; background: #0f1219; border-radius: 4px; border: 1px solid #2a3150;">`;
                        html += `<div style="font-size: 0.75rem; font-weight: 600; margin-bottom: 4px;">Misión ${idx + 1}: ${missionType}</div>`;
                        if (variant) {
                            const variantDesc = getDescription(mission.variant, 'Variant', 'Lab');
                            if (variantDesc) {
                                html += `<div style="font-size: 0.65rem; color: #8b95a5; margin-bottom: 2px;">Variante: <span class="modifier-tooltip">${variant}<span class="tooltip-content">${variantDesc}</span></span></div>`;
                            } else {
                                html += `<div style="font-size: 0.65rem; color: #8b95a5; margin-bottom: 2px;">Variante: ${variant}</div>`;
                            }
                        }
                        if (mission.conditions && mission.conditions.length > 0) {
                            const modifiersHtml = mission.conditions.map(condition => {
                                const conditionName = getTranslation(condition, 'Condition');
                                const conditionDesc = getDescription(condition, 'Condition');
                                if (conditionDesc) {
                                    return `<span class="modifier-tooltip">${conditionName}<span class="tooltip-content">${conditionDesc}</span></span>`;
                                }
                                return conditionName;
                            }).join(', ');
                            html += `<div style="font-size: 0.65rem; color: #C55F7E;">Modificadores: ${modifiersHtml}</div>`;
                        }
                        html += '</div>';
                    });
                    html += '</div>';
                }
                
                // Arquimedea Temporal
                if (archimideans.temporal) {
                    html += '<div style="background: #151933; border: 1px solid #2a3150; border-radius: 6px; padding: 12px;">';
                    html += `<div style="font-size: 0.9rem; font-weight: 700; margin-bottom: 10px; color: #EB6F92;">Arquimedea temporal - ${archimideans.temporal.location}</div>`;
                    
                    // Personal Mods
                    if (archimideans.temporal.personalMods && archimideans.temporal.personalMods.length > 0) {
                        html += '<div style="margin-bottom: 12px; padding: 8px; background: #1a1f3a; border-radius: 4px; border: 1px solid #2a3150;">';
                        html += '<div style="font-size: 0.7rem; font-weight: 600; margin-bottom: 6px; color: #ffffff;">Modificadores Personales:</div>';
                        const modsHtml = archimideans.temporal.personalMods.map(mod => {
                            const modName = getTranslation(mod, 'PersonalMod');
                            const modDesc = getDescription(mod, 'PersonalMod');
                            if (modDesc) {
                                return `<span class="modifier-tooltip" style="display: inline-block; margin: 2px 4px; padding: 3px 8px; background: #0f1219; border-radius: 3px; font-size: 0.65rem;">${modName}<span class="tooltip-content">${modDesc}</span></span>`;
                            }
                            return `<span style="display: inline-block; margin: 2px 4px; padding: 3px 8px; background: #0f1219; border-radius: 3px; font-size: 0.65rem;">${modName}</span>`;
                        }).join('');
                        html += `<div style="display: flex; flex-wrap: wrap;">${modsHtml}</div>`;
                        html += '</div>';
                    }
                    
                    archimideans.temporal.missions.forEach((mission, idx) => {
                        const missionType = translateMissionType(mission.type);
                        const variant = mission.variant ? getTranslation(mission.variant, 'Variant', 'Hex') : '';
                        
                        html += `<div class="mission-item" style="margin-bottom: 8px; padding: 8px; background: #0f1219; border-radius: 4px; border: 1px solid #2a3150;">`;
                        html += `<div style="font-size: 0.75rem; font-weight: 600; margin-bottom: 4px;">Misión ${idx + 1}: ${missionType}</div>`;
                        if (variant) {
                            const variantDesc = getDescription(mission.variant, 'Variant', 'Hex');
                            if (variantDesc) {
                                html += `<div style="font-size: 0.65rem; color: #8b95a5; margin-bottom: 2px;">Variante: <span class="modifier-tooltip">${variant}<span class="tooltip-content">${variantDesc}</span></span></div>`;
                            } else {
                                html += `<div style="font-size: 0.65rem; color: #8b95a5; margin-bottom: 2px;">Variante: ${variant}</div>`;
                            }
                        }
                        if (mission.conditions && mission.conditions.length > 0) {
                            const modifiersHtml = mission.conditions.map(condition => {
                                const conditionName = getTranslation(condition, 'Condition');
                                const conditionDesc = getDescription(condition, 'Condition');
                                if (conditionDesc) {
                                    return `<span class="modifier-tooltip">${conditionName}<span class="tooltip-content">${conditionDesc}</span></span>`;
                                }
                                return conditionName;
                            }).join(', ');
                            html += `<div style="font-size: 0.65rem; color: #C55F7E;">Modificadores: ${modifiersHtml}</div>`;
                        }
                        html += '</div>';
                    });
                    html += '</div>';
                }
                
                // Arquimedea Profunda (solo en view normal, no exclusiva)
                if (!isArquimideasView && archimideans.deep) {
                    html += '<div style="background: #151933; border: 1px solid #2a3150; border-radius: 6px; padding: 12px;">';
                    html += `<div style="font-size: 0.9rem; font-weight: 700; margin-bottom: 10px; color: #EB6F92;">Profunda - ${archimideans.deep.location}</div>`;
                    
                    // Personal Mods para Profunda
                    if (archimideans.deep.personalMods && archimideans.deep.personalMods.length > 0) {
                        html += '<div style="margin-bottom: 12px; padding: 8px; background: #1a1f3a; border-radius: 4px; border: 1px solid #2a3150;">';
                        html += '<div style="font-size: 0.7rem; font-weight: 600; margin-bottom: 6px; color: #ffffff;">Modificadores Personales:</div>';
                        const modsHtml = archimideans.deep.personalMods.map(mod => {
                            const modName = getTranslation(mod, 'PersonalMod');
                            const modDesc = getDescription(mod, 'PersonalMod');
                            if (modDesc) {
                                return `<span class="modifier-tooltip" style="display: inline-block; margin: 2px 4px; padding: 3px 8px; background: #0f1219; border-radius: 3px; font-size: 0.65rem;">${modName}<span class="tooltip-content">${modDesc}</span></span>`;
                            }
                            return `<span style="display: inline-block; margin: 2px 4px; padding: 3px 8px; background: #0f1219; border-radius: 3px; font-size: 0.65rem;">${modName}</span>`;
                        }).join('');
                        html += `<div style="display: flex; flex-wrap: wrap;">${modsHtml}</div>`;
                        html += '</div>';
                    }
                    
                    archimideans.deep.missions.forEach((mission, idx) => {
                        const missionType = translateMissionType(mission.type);
                        const variant = mission.variant ? getTranslation(mission.variant, 'Variant', 'Lab') : '';
                        
                        html += `<div class="mission-item" style="margin-bottom: 8px; padding: 8px; background: #0f1219; border-radius: 4px; border: 1px solid #2a3150;">`;
                        html += `<div style="font-size: 0.75rem; font-weight: 600; margin-bottom: 4px;">Misión ${idx + 1}: ${missionType}</div>`;
                        if (variant) {
                            const variantDesc = getDescription(mission.variant, 'Variant', 'Lab');
                            if (variantDesc) {
                                html += `<div style="font-size: 0.65rem; color: #8b95a5; margin-bottom: 2px;">Variante: <span class="modifier-tooltip">${variant}<span class="tooltip-content">${variantDesc}</span></span></div>`;
                            } else {
                                html += `<div style="font-size: 0.65rem; color: #8b95a5; margin-bottom: 2px;">Variante: ${variant}</div>`;
                            }
                        }
                        if (mission.conditions && mission.conditions.length > 0) {
                            const modifiersHtml = mission.conditions.map(condition => {
                                const conditionName = getTranslation(condition, 'Condition');
                                const conditionDesc = getDescription(condition, 'Condition');
                                if (conditionDesc) {
                                    return `<span class="modifier-tooltip">${conditionName}<span class="tooltip-content">${conditionDesc}</span></span>`;
                                }
                                return conditionName;
                            }).join(', ');
                            html += `<div style="font-size: 0.65rem; color: #C55F7E;">Modificadores: ${modifiersHtml}</div>`;
                        }
                        html += '</div>';
                    });
                    html += '</div>';
                }
                
                html += '</div>'; // fin gridStyle
                if (isArquimideasView) html += '</div>'; // fin containerStyle
                html += '</div>'; // fin container principal
            }
            
            document.getElementById('archimidean-content').innerHTML = html;
        }
        
        // Renderizar sidebar con ciclos e invasiones
        function renderSidebar() {
            const cycles = gameData.cycles || {};
            const invasions = gameData.invasions || [];
            const sortie = gameData.sortie;
            const archonHunt = gameData.archonHunt;
            
            // Filtrar según VIEW_FILTER
            const showCiclos = !window.VIEW_FILTER || window.VIEW_FILTER === 'ciclos' || window.VIEW_FILTER === 'ciclos_invasiones';
            const showInvasiones = !window.VIEW_FILTER || window.VIEW_FILTER === 'invasiones' || window.VIEW_FILTER === 'ciclos_invasiones';
            const horizontalTimers = window.VIEW_FILTER === 'ciclos_invasiones';
            const isCombinedView = window.VIEW_FILTER === 'ciclos_invasiones';
            
            // Vista especial: Grid 2x2 con Sortie y Archon al lado
            if (isCombinedView) {
                let gridHtml = '<div style="display: grid; grid-template-columns: minmax(300px, 1fr) minmax(300px, 1fr); gap: 15px; max-width: 1400px; margin: 0 auto;">';
                
                // Fila 1: Ciclos (izquierda) + Sortie (derecha)
                gridHtml += '<div class="sidebar-section">';
                gridHtml += '<div class="sidebar-header" style="color: #EB6F92;">Ciclos</div>';
                
                // Cetus
                if (cycles.cetus) {
                    const cetusIcon = cycles.cetus.isDay ? '☀️' : '🌙';
                    const cetusState = cycles.cetus.isDay ? 'Día' : 'Noche';
                    gridHtml += `<div class="sidebar-item" style="display: flex; justify-content: space-between; align-items: center;"><div>${cetusIcon} <strong>Cetus:</strong> ${cetusState}</div><div class="timer" data-expiry="${cycles.cetus.expiry}">${formatTime(getTimeRemaining(cycles.cetus.expiry))}</div></div>`;
                }
                // Orb Vallis
                if (cycles.vallis) {
                    const vallisIcon = cycles.vallis.isWarm ? '☀️' : '❄️';
                    const vallisState = cycles.vallis.isWarm ? 'Cálido' : 'Frío';
                    gridHtml += `<div class="sidebar-item" style="display: flex; justify-content: space-between; align-items: center;"><div>${vallisIcon} <strong>Orb Vallis:</strong> ${vallisState}</div><div class="timer" data-expiry="${cycles.vallis.expiry}">${formatTime(getTimeRemaining(cycles.vallis.expiry))}</div></div>`;
                }
                // Cambion
                if (cycles.cambion) {
                    const cambionIcon = cycles.cambion.active === 'fass' ? '🔴' : '🔵';
                    const cambionState = cycles.cambion.active === 'fass' ? 'Fass' : 'Vome';
                    gridHtml += `<div class="sidebar-item" style="display: flex; justify-content: space-between; align-items: center;"><div>${cambionIcon} <strong>Cambion:</strong> ${cambionState}</div><div class="timer" data-expiry="${cycles.cambion.expiry}">${formatTime(getTimeRemaining(cycles.cambion.expiry))}</div></div>`;
                }
                // Zariman
                if (cycles.zariman) {
                    const zarimanIcon = cycles.zariman.state === 'Grineer' ? '🔴' : '🔵';
                    gridHtml += `<div class="sidebar-item" style="display: flex; justify-content: space-between; align-items: center;"><div>${zarimanIcon} <strong>Zariman:</strong> ${cycles.zariman.state}</div><div class="timer" data-expiry="${cycles.zariman.expiry}">${formatTime(getTimeRemaining(cycles.zariman.expiry))}</div></div>`;
                }
                // Duviri
                if (cycles.duviri) {
                    const duvirIcon = cycles.duviri.icon || '';
                    gridHtml += `<div class="sidebar-item" style="display: flex; justify-content: space-between; align-items: center;"><div>${duvirIcon} <strong>Duviri:</strong> ${cycles.duviri.state}</div><div class="timer" data-expiry="${cycles.duviri.expiry}">${formatTime(getTimeRemaining(cycles.duviri.expiry))}</div></div>`;
                }
                gridHtml += '</div>';
                
                // Sortie (derecha, fila 1)
                gridHtml += '<div class="sidebar-section">';
                if (sortie) {
                    const remaining = getTimeRemaining(sortie.expiry);
                    gridHtml += `<div style="font-size: 0.85rem; font-weight: 700; margin-bottom: 10px; color: #EB6F92; text-align: center; padding-bottom: 8px; border-bottom: 1px solid #2a3150;">Sortie - ${sortie.boss}</div>`;
                    gridHtml += `<div style="font-size: 0.7rem; color: #8b95a5; text-align: center; margin-bottom: 10px;">Rota en: <span class="timer" data-expiry="${sortie.expiry}">${formatTime(remaining)}</span></div>`;
                    sortie.missions.forEach(mission => {
                        gridHtml += `<div class="mission-item" style="margin-bottom: 8px; padding: 10px 12px; background: #151933; border-radius: 4px; border: 1px solid #2a3150;">`;
                        gridHtml += `<div style="font-size: 0.75rem; font-weight: 600; margin-bottom: 3px;">${mission.index}. ${mission.missionType}</div>`;
                        gridHtml += `<div style="font-size: 0.65rem; color: #8b95a5; margin-bottom: 2px;">${mission.node} - ${mission.enemy}</div>`;
                        gridHtml += `<div style="font-size: 0.65rem; color: #C55F7E;">${mission.modifier}</div>`;
                        gridHtml += `</div>`;
                    });
                }
                gridHtml += '</div>';
                
                // Fila 2: Invasiones (izquierda) + Archon Hunt (derecha)
                gridHtml += '<div class="sidebar-section">';
                gridHtml += '<div class="sidebar-header" style="color: #EB6F92;">Invasiones</div>';
                if (invasions.length > 0) {
                    invasions.forEach(inv => {
                        gridHtml += `<div class="sidebar-item"><div style="font-weight: 600; margin-bottom: 4px;">${inv.node}</div>`;
                        gridHtml += `<div style="font-size: 0.65rem; color: #8b95a5; margin-bottom: 2px;">${inv.missions.join(', ')}</div>`;
                        gridHtml += `<div style="font-size: 0.65rem; margin-bottom: 3px;">🔴 ${inv.attacker}: ${inv.reward1}</div>`;
                        gridHtml += inv.reward2 ? `<div style="font-size: 0.65rem;">🔵 ${inv.defender}: ${inv.reward2}</div>` : `<div style="font-size: 0.65rem; color: #666;">🔵 ${inv.defender}: Sin recompensa</div>`;
                        gridHtml += '</div>';
                    });
                } else {
                    gridHtml += '<div class="sidebar-item">No hay invasiones activas</div>';
                }
                gridHtml += '</div>';
                
                // Archon Hunt (derecha, fila 2)
                gridHtml += '<div class="sidebar-section">';
                if (archonHunt) {
                    const remaining = getTimeRemaining(archonHunt.expiry);
                    gridHtml += `<div style="font-size: 0.85rem; font-weight: 700; margin-bottom: 8px; color: #EB6F92; text-align: center; padding-bottom: 8px; border-bottom: 1px solid #2a3150;">${archonHunt.boss}</div>`;
                    gridHtml += `<div style="font-size: 0.65rem; color: #C55F7E; text-align: center; margin-bottom: 8px;">${archonHunt.crystal}</div>`;
                    gridHtml += `<div style="font-size: 0.7rem; color: #8b95a5; text-align: center; margin-bottom: 10px;">Rota en: <span class="timer" data-expiry="${archonHunt.expiry}">${formatTime(remaining)}</span></div>`;
                    archonHunt.missions.forEach(mission => {
                        gridHtml += `<div class="mission-item" style="margin-bottom: 8px; padding: 10px 12px; background: #151933; border-radius: 4px; border: 1px solid #2a3150;">`;
                        gridHtml += `<div style="font-size: 0.75rem; font-weight: 600; margin-bottom: 3px;">${mission.index}. ${mission.missionType}</div>`;
                        gridHtml += `<div style="font-size: 0.65rem; color: #8b95a5;">${mission.node} - ${mission.enemy}</div>`;
                        gridHtml += `</div>`;
                    });
                }
                gridHtml += '</div>';
                
                gridHtml += '</div>'; // fin grid 2x2
                document.getElementById('sidebar').innerHTML = gridHtml;
                return;
            }
            
            let html = '';
            
            if (showCiclos) {
                html += '<div class="sidebar-section">';
                html += '<div class="sidebar-header" style="color: #EB6F92;">Ciclos</div>';
            }
            
            if (!showCiclos && !showInvasiones) {
                return; // No renderizar nada si no corresponde
            }
            
            if (showCiclos) {
            
            // Cetus
            if (cycles.cetus) {
                const cetusIcon = cycles.cetus.isDay ? '☀️' : '🌙';
                const cetusState = cycles.cetus.isDay ? 'Día' : 'Noche';
                if (horizontalTimers) {
                    html += `
                        <div class="sidebar-item" style="display: flex; justify-content: space-between; align-items: center;">
                            <div>${cetusIcon} <strong>Cetus:</strong> ${cetusState}</div>
                            <div class="timer" data-expiry="${cycles.cetus.expiry}">${formatTime(getTimeRemaining(cycles.cetus.expiry))}</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="sidebar-item">
                            ${cetusIcon} <strong>Cetus:</strong> ${cetusState}
                            <div class="timer" data-expiry="${cycles.cetus.expiry}">${formatTime(getTimeRemaining(cycles.cetus.expiry))}</div>
                        </div>
                    `;
                }
            } else {
                html += `<div class="sidebar-item"><strong>Cetus:</strong> No disponible</div>`;
            }
            
            // Orb Vallis
            if (cycles.vallis) {
                const vallisIcon = cycles.vallis.isWarm ? '☀️' : '❄️';
                const vallisState = cycles.vallis.isWarm ? 'Cálido' : 'Frío';
                if (horizontalTimers) {
                    html += `
                        <div class="sidebar-item" style="display: flex; justify-content: space-between; align-items: center;">
                            <div>${vallisIcon} <strong>Orb Vallis:</strong> ${vallisState}</div>
                            <div class="timer" data-expiry="${cycles.vallis.expiry}">${formatTime(getTimeRemaining(cycles.vallis.expiry))}</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="sidebar-item">
                            ${vallisIcon} <strong>Orb Vallis:</strong> ${vallisState}
                            <div class="timer" data-expiry="${cycles.vallis.expiry}">${formatTime(getTimeRemaining(cycles.vallis.expiry))}</div>
                        </div>
                    `;
                }
            }
            
            // Cambion Drift
            if (cycles.cambion) {
                const cambionIcon = cycles.cambion.active === 'fass' ? '🔴' : '🔵';
                const cambionState = cycles.cambion.active === 'fass' ? 'Fass' : 'Vome';
                if (horizontalTimers) {
                    html += `
                        <div class="sidebar-item" style="display: flex; justify-content: space-between; align-items: center;">
                            <div>${cambionIcon} <strong>Cambion:</strong> ${cambionState}</div>
                            <div class="timer" data-expiry="${cycles.cambion.expiry}">${formatTime(getTimeRemaining(cycles.cambion.expiry))}</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="sidebar-item">
                            ${cambionIcon} <strong>Cambion:</strong> ${cambionState}
                            <div class="timer" data-expiry="${cycles.cambion.expiry}">${formatTime(getTimeRemaining(cycles.cambion.expiry))}</div>
                        </div>
                    `;
                }
            }
            
            // Zariman
            if (cycles.zariman) {
                const zarimanIcon = cycles.zariman.state === 'Grineer' ? '🔴' : '🔵';
                if (horizontalTimers) {
                    html += `
                        <div class="sidebar-item" style="display: flex; justify-content: space-between; align-items: center;">
                            <div>${zarimanIcon} <strong>Zariman:</strong> ${cycles.zariman.state}</div>
                            <div class="timer" data-expiry="${cycles.zariman.expiry}">${formatTime(getTimeRemaining(cycles.zariman.expiry))}</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="sidebar-item">
                            ${zarimanIcon} <strong>Zariman:</strong> ${cycles.zariman.state}
                            <div class="timer" data-expiry="${cycles.zariman.expiry}">${formatTime(getTimeRemaining(cycles.zariman.expiry))}</div>
                        </div>
                    `;
                }
            }
            
            // Duviri
            if (cycles.duviri) {
                const duviriIcons = {
                    'Joy': '',
                    'Anger': '',
                    'Envy': '',
                    'Sorrow': '',
                    'Fear': ''
                };
                const duviriIcon = duviriIcons[cycles.duviri.state] || '';
                if (horizontalTimers) {
                    html += `
                        <div class="sidebar-item" style="display: flex; justify-content: space-between; align-items: center;">
                            <div>${duviriIcon} <strong>Duviri:</strong> ${cycles.duviri.state}</div>
                            <div class="timer" data-expiry="${cycles.duviri.expiry}">${formatTime(getTimeRemaining(cycles.duviri.expiry))}</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="sidebar-item">
                            ${duviriIcon} <strong>Duviri:</strong> ${cycles.duviri.state}
                            <div class="timer" data-expiry="${cycles.duviri.expiry}">${formatTime(getTimeRemaining(cycles.duviri.expiry))}</div>
                        </div>
                    `;
                }
            } else {
                html += `<div class="sidebar-item"><strong>Duviri:</strong> No disponible</div>`;
            }
            
                html += '</div>'; // fin sidebar-section ciclos
            }
            
            // Invasiones
            if (showInvasiones) {
                html += '<div class="sidebar-section">';
                html += '<div style="color: #EB6F92;" class="sidebar-header">Invasiones</div>';
            }
            
            if (showInvasiones) {
            
                if (invasions.length > 0) {
                    invasions.forEach(inv => {
                        html += `
                            <div class="sidebar-item">
                                <div style="font-weight: 600; margin-bottom: 4px;">${inv.node}</div>
                                <div style="font-size: 0.65rem; color: #8b95a5; margin-bottom: 2px;">
                                    ${inv.missions.join(', ')}
                                </div>
                                <div style="font-size: 0.65rem; margin-bottom: 3px;">
                                    🔴 ${inv.attacker}: ${inv.reward1}
                                </div>
                                ${inv.reward2 ? `<div style="font-size: 0.65rem;">
                                    🔵 ${inv.defender}: ${inv.reward2}
                                </div>` : `<div style="font-size: 0.65rem; color: #666;">
                                    🔵 ${inv.defender}: Sin recompensa
                                </div>`}
                            </div>
                        `;
                    });
                } else {
                    html += '<div class="sidebar-item">No hay invasiones activas</div>';
                }
                
                html += '</div>'; // fin sidebar-section invasiones
            }
            
            document.getElementById('sidebar').innerHTML = html;
        }
        
        /* ===== ROUTING: VISTAS ESPECÍFICAS ===== */
        
        // Obtener el parámetro 'view' de la URL
        function getViewMode() {
            const params = new URLSearchParams(window.location.search);
            return params.get('view'); // null si no hay parámetro
        }
        
        // Ocultar/mostrar secciones según la vista
        function applyViewMode() {
            const view = getViewMode();
            
            if (!view) {
                // Vista completa (por defecto) - mostrar todo
                return;
            }
            
            // Ocultar todo primero
            const header = document.querySelector('header');
            const separator = document.querySelector('.separator');
            const mainLayout = document.querySelector('.main-layout');
            const missionsContent = document.getElementById('missions-content');
            const archimideanContent = document.getElementById('archimidean-content');
            const footer = document.querySelector('footer');
            
            // Ocultar elementos por defecto
            if (header) header.style.display = 'none';
            if (separator) separator.style.display = 'none';
            if (footer) footer.style.display = 'none';
            
            // Mostrar solo la sección pedida con el link
            switch(view) {
                case 'fisuras':
                    // Solo fisuras (lado derecho del main-layout)
                    if (mainLayout) {
                        const sidebar = mainLayout.querySelector('.sidebar');
                        if (sidebar) sidebar.style.display = 'none';
                    }
                    if (missionsContent) missionsContent.style.display = 'none';
                    if (archimideanContent) archimideanContent.style.display = 'none';
                    break;
                    
                case 'ciclos':
                    // Solo ciclos (sidebar, sin invasiones)
                    if (mainLayout) {
                        const fissuresContent = mainLayout.querySelector('#fissures-content');
                        if (fissuresContent) fissuresContent.style.display = 'none';
                    }
                    if (missionsContent) missionsContent.style.display = 'none';
                    if (archimideanContent) archimideanContent.style.display = 'none';
                    // Necesitamos filtrar invasiones en renderSidebar
                    window.VIEW_FILTER = 'ciclos';
                    break;
                    
                case 'invasiones':
                    // Solo invasiones (sidebar, sin ciclos)
                    if (mainLayout) {
                        const fissuresContent = mainLayout.querySelector('#fissures-content');
                        if (fissuresContent) fissuresContent.style.display = 'none';
                    }
                    if (missionsContent) missionsContent.style.display = 'none';
                    if (archimideanContent) archimideanContent.style.display = 'none';
                    window.VIEW_FILTER = 'invasiones';
                    break;
                    
                case 'ciclos_invasiones':
                    // Vista combinada: grid 2x2 (ciclos+sortie | invasiones+archon)
                    if (mainLayout) {
                        const fissuresContent = mainLayout.querySelector('#fissures-content');
                        if (fissuresContent) fissuresContent.style.display = 'none';
                    }
                    // missions-content se oculta porque Sortie/Archon se renderizan en sidebar
                    if (missionsContent) missionsContent.style.display = 'none';
                    if (archimideanContent) archimideanContent.style.display = 'none';
                    window.VIEW_FILTER = 'ciclos_invasiones';
                    break;
                    
                case 'sortie':
                    // Solo Sortie
                    if (mainLayout) mainLayout.style.display = 'none';
                    if (archimideanContent) archimideanContent.style.display = 'none';
                    window.VIEW_FILTER = 'sortie';
                    break;
                    
                case 'archon':
                    // Solo Cacería de Arcontes
                    if (mainLayout) mainLayout.style.display = 'none';
                    if (archimideanContent) archimideanContent.style.display = 'none';
                    window.VIEW_FILTER = 'archon';
                    break;
                    
                case 'arquimedeas':
                    // Solo Arquímedeas en vertical
                    if (mainLayout) mainLayout.style.display = 'none';
                    if (missionsContent) missionsContent.style.display = 'none';
                    window.VIEW_FILTER = 'arquimedeas';
                    break;
                    
                case 'incarnon':
                    // Panel exclusivo: Rotación de Armas Incarnon
                    if (mainLayout) mainLayout.style.display = 'none';
                    if (missionsContent) missionsContent.style.display = 'none';
                    if (archimideanContent) archimideanContent.style.display = 'none';
                    renderIncarnonRotation();
                    break;
                    
                case 'circuito':
                    // Panel exclusivo: Rotación de Warframes en Circuito
                    if (mainLayout) mainLayout.style.display = 'none';
                    if (missionsContent) missionsContent.style.display = 'none';
                    if (archimideanContent) archimideanContent.style.display = 'none';
                    renderCircuitRotation();
                    break;
                    
                case 'teshin':
                    // Panel exclusivo: Tienda de Teshin
                    if (mainLayout) mainLayout.style.display = 'none';
                    if (missionsContent) missionsContent.style.display = 'none';
                    if (archimideanContent) archimideanContent.style.display = 'none';
                    renderTeshinRotation();
                    break;
                    
                default:
                    // Vista desconocida, mostrar todo
                    console.warn(`Vista desconocida: ${view}`);
            }
        }
        
        /* ===== FUNCIONES DE ROTACIONES EXCLUSIVAS ===== */
        
        // Renderizar rotación de Armas Incarnon
        function renderIncarnonRotation() {
            const currentWeek = getCurrentWeek(8, 'incarnon');
            
            let html = '<div style="max-width: 700px; margin: 20px auto;">';
            html += '<div style="text-align: center; margin-bottom: 20px;">';
            html += '<h2 style="color: #EB6F92; font-size: 1.8rem; margin-bottom: 10px;"></h2>';
            html += '<div style="font-size: 0.85rem; color: #8b95a5;"></div>';
            html += '</div>';
            
            html += '<div style="display: grid; gap: 8px;">';
            INCARNON_ROTATION.forEach(rotation => {
                const isActive = rotation.week === currentWeek;
                const bgColor = isActive ? '#1a2332' : '#0f1219';
                const borderColor = isActive ? '#EB6F92' : '#1a1f3a';
                const borderWidth = isActive ? '2px' : '1px';
                
                html += `<div class="rotation-item" style="background: ${bgColor}; padding: 10px 12px; border-radius: 8px; border: ${borderWidth} solid ${borderColor}; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); cursor: default;">`;
                html += `<div style="display: flex; align-items: center; gap: 10px;">`;
                html += `<div style="font-size: 1.2rem; font-weight: 700; color: ${isActive ? '#EB6F92' : '#CBA9FE'}; min-width: 100px;">Semana ${rotation.week}</div>`;
                html += `<div style="flex: 1; display: flex; flex-wrap: wrap; gap: 8px;">`;
                
                rotation.weapons.forEach(weapon => {
                    html += `<span style="background: #151933; padding: 6px 12px; border-radius: 4px; font-size: 0.8rem; color: ${isActive ? '#e0e6ed' : '#8b95a5'};">${weapon}</span>`;
                });
                
                html += `</div>`;
                if (isActive) {
                    html += `<div style="background: #EB6F92; color: #0f1219; padding: 4px 10px; border-radius: 4px; font-size: 0.7rem; font-weight: 600;">ACTIVA</div>`;
                }
                html += `</div></div>`;
            });
            html += '</div></div>';
            
            document.getElementById('rotations-content').innerHTML = html;
            applyRotationHoverEffects();
        }
        
        // Renderizar rotación de Warframes en Circuito
        function renderCircuitRotation() {
            const currentWeek = getCurrentWeek(11, 'circuit');
            
            let html = '<div style="max-width: 500px; margin: 20px auto;">';
            html += '<div style="text-align: center; margin-bottom: 20px;">';
            html += '<h2 style="color: #EB6F92; font-size: 1.8rem; margin-bottom: 10px;"></h2>';
            html += '<div style="font-size: 0.85rem; color: #8b95a5;"></div>';
            html += '</div>';
            
            html += '<div style="display: grid; gap: 8px;">';
            CIRCUIT_ROTATION.forEach(rotation => {
                const isActive = rotation.week === currentWeek;
                const bgColor = isActive ? '#1a2332' : '#0f1219';
                const borderColor = isActive ? '#EB6F92' : '#1a1f3a';
                const borderWidth = isActive ? '2px' : '1px';
                
                html += `<div class="rotation-item" style="background: ${bgColor}; padding: 10px 12px; border-radius: 8px; border: ${borderWidth} solid ${borderColor}; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); cursor: default;">`;
                html += `<div style="display: flex; align-items: center; gap: 10px;">`;
                html += `<div style="font-size: 1.2rem; font-weight: 700; color: ${isActive ? '#EB6F92' : '#CBA9FE'}; min-width: 100px;">Semana ${rotation.week}</div>`;
                html += `<div style="flex: 1; display: flex; flex-wrap: wrap; gap: 8px;">`;
                
                rotation.frames.forEach(frame => {
                    html += `<span style="background: #151933; padding: 6px 12px; border-radius: 4px; font-size: 0.8rem; color: ${isActive ? '#e0e6ed' : '#8b95a5'};">${frame}</span>`;
                });
                
                html += `</div>`;
                if (isActive) {
                    html += `<div style="background: #EB6F92; color: #0f1219; padding: 4px 10px; border-radius: 4px; font-size: 0.7rem; font-weight: 600;">ACTIVA</div>`;
                }
                html += `</div></div>`;
            });
            html += '</div></div>';
            
            document.getElementById('rotations-content').innerHTML = html;
            applyRotationHoverEffects();
        }
        
        // Renderizar rotación de Tienda de Teshin
        function renderTeshinRotation() {
            const currentWeek = getCurrentWeek(8, 'teshin');
            
            let html = '<div style="max-width: 450px; margin: 20px auto;">';
            html += '<div style="text-align: center; margin-bottom: 20px;">';
            html += '<h2 style="color: #EB6F92; font-size: 1.8rem; margin-bottom: 10px;"></h2>';
            html += '<div style="font-size: 0.85rem; color: #8b95a5;"></div>';
            html += '</div>';
            
            html += '<div style="display: grid; gap: 8px;">';
            TESHIN_ROTATION.forEach(rotation => {
                const isActive = rotation.week === currentWeek;
                const bgColor = isActive ? '#1a2332' : '#0f1219';
                const borderColor = isActive ? '#EB6F92' : '#1a1f3a';
                const borderWidth = isActive ? '2px' : '1px';
                
                html += `<div class="rotation-item" style="background: ${bgColor}; padding: 10px 12px; border-radius: 8px; border: ${borderWidth} solid ${borderColor}; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); cursor: default;">`;
                html += `<div style="display: flex; align-items: center; justify-content: space-between;">`;
                html += `<div style="font-size: 1.1rem; font-weight: 700; color: ${isActive ? '#EB6F92' : '#CBA9FE'};">Semana ${rotation.week}</div>`;
                
                rotation.items.forEach(item => {
                    html += `<div style="flex: 1; margin: 0 15px;">`;
                    html += `<div style="font-size: 0.9rem; color: ${isActive ? '#e0e6ed' : '#8b95a5'}; font-weight: 600;">${item.name}</div>`;
                    html += `<div style="font-size: 0.75rem; color: #F4C076; margin-top: 3px;">${item.cost}</div>`;
                    html += `</div>`;
                });
                
                if (isActive) {
                    html += `<div style="background: #EB6F92; color: #0f1219; padding: 4px 10px; border-radius: 4px; font-size: 0.7rem; font-weight: 600;">ACTIVA</div>`;
                }
                html += `</div></div>`;
            });
            html += '</div></div>';
            
            document.getElementById('rotations-content').innerHTML = html;
            applyRotationHoverEffects();
        }
        
        // Aplicar efectos hover a los items de rotación
        function applyRotationHoverEffects() {
            const items = document.querySelectorAll('.rotation-item');
            items.forEach(item => {
                item.addEventListener('mouseenter', function() {
                    this.style.borderColor = '#667eea';
                    this.style.transform = 'translateX(4px)';
                    this.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.15)';
                });
                item.addEventListener('mouseleave', function() {
                    const isActive = this.style.borderWidth === '2px';
                    this.style.borderColor = isActive ? '#EB6F92' : '#1a1f3a';
                    this.style.transform = 'translateX(0)';
                    this.style.boxShadow = 'none';
                });
            });
        }
        
        /* ===== INICIALIZACIÓN ===== */
        
        // Inicializar la aplicación
        async function init() {
            console.log('Iniciando...');
            applyViewMode(); // Aplicar filtro de vista
            await loadNodeData(); // Cargar datos de nodos
            await loadSortieData(); // Cargar datos de Sortie
            await loadOracleTranslations(); // Cargar traducciones de Oracle
            await fetchData(); // Cargar fisuras
            setInterval(updateTimers, 1000); // Actualizar timers cada 1 segundo
            setInterval(fetchData, 30000); // Actualizar datos cada 30 segundos
        }
        
        // Ejecutar al cargar la página
        init();
    </script>
</body>
</html>
